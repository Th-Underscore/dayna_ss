from subprocess import Popen
import sys
import copy
import json
import pathlib
import pprint
import subprocess
import asyncio
import threading
import os
from typing import List, Tuple, Dict, Optional, Coroutine
import traceback

import extensions.dayna_story_summarizer.config as config
from utils._old.tree_handling import Tree, TreeEditor
from extensions.dayna_story_summarizer.agents.summarizer import Summarizer

# Colour codes
_ERROR = "\033[1;31m"
_SUCCESS = "\033[1;32m"
_INPUT = "\033[0;33m"
_GRAY = "\033[0;30m"
_HILITE = "\033[0;36m"
_BOLD = "\033[1;37m"
_RESET = "\033[0m"

_DEBUG = "\033[1;31m||\033[0;32m"

# === Internal constants (don't change these without good reason) ===
_CONFIG_PATH = "extensions/dayna_story_summarizer/dss_config.json"

# Global event loop for background tasks
_background_loop = None
_loop_thread = None

def ensure_background_loop():
    """Ensure a background event loop is running in a separate thread"""
    global _background_loop, _loop_thread
    
    def run_event_loop(loop):
        asyncio.set_event_loop(loop)
        loop.run_forever()
    
    if _background_loop is None:
        _background_loop = asyncio.new_event_loop()
        _loop_thread = threading.Thread(target=run_event_loop, args=(_background_loop,), daemon=True)
        _loop_thread.start()

def setup():
    """Initialize the extension"""
    global summarizer, story_rag
    print("Loaded Super Story Summarizer!")
    
    # Initialize summarizer
    summarizer = Summarizer(_CONFIG_PATH)
    story_rag = True
    # story_rag = summarizer.story_rag
    
    # Load example data (change this to actual data source)
    # story_rag.load_from_json("extensions/dayna_story_summarizer/utils/examples/post_apocalyptic.json")

    # Load and set up tree
    config_file = f"./extensions/dayna_story_summarizer/user_data/config/{config.current_character}.json"
    sbj_tree = config.load_json_with_fallback(config_file)
    
    config.tree_editor = TreeEditor(copy.deepcopy(sbj_tree))
    config.tree_editor.json_data = sbj_tree
    config.tree = Tree(config.tree_editor)

def run_async(coro: Coroutine) -> Optional[any]:
    """Run an async function in the current thread.

    Args:
        coro (Coroutine): An async coroutine to be run.

    Returns:
        Optional[any]: The result of the coroutine if successful, otherwise None.
    """
    print(f"{_BOLD}Running async:{_RESET} {coro}")
    try:
        ensure_background_loop()
        future = asyncio.run_coroutine_threadsafe(coro, _background_loop)
        return future
    except Exception as e:
        print(f"{_ERROR}Error in async execution:{_RESET} {str(e)}")
        return None

def custom_generate_chat_prompt(user_input: str, state: Dict, **kwargs):
    global summarizer
    from modules.chat import generate_chat_prompt
    if not summarizer:
        summarizer = Summarizer(_CONFIG_PATH)
    
    try:
        impersonate = kwargs.get('impersonate')
        print(config.update_config(state))
        print('impersonate', impersonate, 'user_input', user_input)
        
        instr_prompt, custom_state, history_path = summarizer.get_summary_prompt(user_input, state, **kwargs)
        index = len(state['history']['visible']) * 2 - 1  # User input index
        summarizer.save_message_chunks(user_input, index)
        
        #kwargs['history'] = copy.deepcopy(custom_state['history'])
        kwargs.pop('history')
        kwargs.pop('_continue', False)
        prompt = generate_chat_prompt(instr_prompt, custom_state, **kwargs)
        with open(history_path / "dump.txt", "a") as f:
            dump_str = "==========================\n"
            dump_str += "==========================\n"
            dump_str += "==========================\n"
            dump_str += "==========================\n\n"
            dump_str += prompt
            f.write(dump_str)
            f.close()
        
        return generate_chat_prompt(instr_prompt, custom_state, **kwargs)
    except Exception as e:
        print(f"{_ERROR}Error generating custom summarization prompt:{_RESET} {str(e)}")
        traceback.print_exc()
        return generate_chat_prompt(user_input, state, **kwargs)

def output_modifier(output: str, state: Dict, is_chat: Optional[bool]):
    """Generate new history data using output after it is generated by the model"""
    print('output_modifier')
    global summarizer, story_rag
    
    if not summarizer or not story_rag:
        return output
    
    async def process_summarizations():
        index = len(state['history']['visible']) * 2  # Output index
        summarizer.save_message_chunks(output, index)
        try:
            # Reset sequence before processing new batch of prompts
            summarizer.vram_manager.reset_sequence()
            
            summarizer.summarize_message(output, state)
                        
        except Exception as e:
            print(f"{_ERROR}Error during summarization:{_RESET} {str(e)}")
            traceback.print_exc()
    
    # Create task and let it run in background
    run_async(process_summarizations())
    
    return output

def debug(msg: str):
    print(f"\033[0;{30}m" + msg)

print("----------")
print("DSS CONFIG")
print("----------")
print("change these values in dss_config.json")
# pprint.pprint(_CONFIG)
print("----------")

def main():
    setup()

if __name__ == "__main__":
    main()